<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Probation review report</title>
  <meta name="description" content="Probation review report">
  <meta name="generator" content="bookdown 0.5 and GitBook 2.6.7">

  <meta property="og:title" content="Probation review report" />
  <meta property="og:type" content="book" />
  
  
  
  <meta name="github-repo" content="ellessenne/prr" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Probation review report" />
  
  
  

<meta name="author" content="Alessandro Gasparini">


<meta name="date" content="2017-09-04">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="compch.html">
<link rel="next" href="compch-numdiff.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />










<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Introduction</a></li>
<li class="chapter" data-level="1" data-path="terminology-notation.html"><a href="terminology-notation.html"><i class="fa fa-check"></i><b>1</b> Terminology and notation</a></li>
<li class="chapter" data-level="2" data-path="smre.html"><a href="smre.html"><i class="fa fa-check"></i><b>2</b> Survival models with random effects</a><ul>
<li class="chapter" data-level="2.1" data-path="smre-univariate-frailty.html"><a href="smre-univariate-frailty.html"><i class="fa fa-check"></i><b>2.1</b> Univariate frailty models</a></li>
<li class="chapter" data-level="2.2" data-path="smre-shared-frailty.html"><a href="smre-shared-frailty.html"><i class="fa fa-check"></i><b>2.2</b> Shared frailty models</a></li>
<li class="chapter" data-level="2.3" data-path="smre-random-effects.html"><a href="smre-random-effects.html"><i class="fa fa-check"></i><b>2.3</b> Alternative formulation</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="jm.html"><a href="jm.html"><i class="fa fa-check"></i><b>3</b> Joint models for longitudinal and survival data</a><ul>
<li class="chapter" data-level="3.1" data-path="jm-formulation.html"><a href="jm-formulation.html"><i class="fa fa-check"></i><b>3.1</b> Model formulation</a></li>
<li class="chapter" data-level="3.2" data-path="jm-estimation.html"><a href="jm-estimation.html"><i class="fa fa-check"></i><b>3.2</b> Estimation process</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="compch.html"><a href="compch.html"><i class="fa fa-check"></i><b>4</b> Computational challenges in survival models with random effects</a><ul>
<li class="chapter" data-level="4.1" data-path="compch-numintgr.html"><a href="compch-numintgr.html"><i class="fa fa-check"></i><b>4.1</b> Numerical integration</a><ul>
<li class="chapter" data-level="4.1.1" data-path="compch-numintgr.html"><a href="compch-numintgr.html#compch-numintgr-uni"><i class="fa fa-check"></i><b>4.1.1</b> Unidimensional functions</a></li>
<li class="chapter" data-level="4.1.2" data-path="compch-numintgr.html"><a href="compch-numintgr.html#compch-numintgr-multi"><i class="fa fa-check"></i><b>4.1.2</b> Multidimensional functions</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="compch-numdiff.html"><a href="compch-numdiff.html"><i class="fa fa-check"></i><b>4.2</b> Numerical differentiation</a></li>
<li class="chapter" data-level="4.3" data-path="compch-numroot.html"><a href="compch-numroot.html"><i class="fa fa-check"></i><b>4.3</b> Numerical root finding</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="simst1.html"><a href="simst1.html"><i class="fa fa-check"></i><b>5</b> Simulation study: accuracy of Gaussian quadrature</a><ul>
<li class="chapter" data-level="5.1" data-path="simst1-dgms.html"><a href="simst1-dgms.html"><i class="fa fa-check"></i><b>5.1</b> Data-generating mechanisms</a></li>
<li class="chapter" data-level="5.2" data-path="simst1-methods-est-pm.html"><a href="simst1-methods-est-pm.html"><i class="fa fa-check"></i><b>5.2</b> Methods, estimands, and performance measures</a></li>
<li class="chapter" data-level="5.3" data-path="simst1-res.html"><a href="simst1-res.html"><i class="fa fa-check"></i><b>5.3</b> Results</a><ul>
<li class="chapter" data-level="5.3.1" data-path="simst1-res.html"><a href="simst1-res.html#aim-1-accuracy-compared-to-analytical-formulae"><i class="fa fa-check"></i><b>5.3.1</b> Aim 1: accuracy compared to analytical formulae</a></li>
<li class="chapter" data-level="5.3.2" data-path="simst1-res.html"><a href="simst1-res.html#aim-2-accuracy-when-analytical-formulae-are-not-available"><i class="fa fa-check"></i><b>5.3.2</b> Aim 2: accuracy when analytical formulae are not available</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="simst1-conclusions.html"><a href="simst1-conclusions.html"><i class="fa fa-check"></i><b>5.4</b> Conclusions</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="simst2.html"><a href="simst2.html"><i class="fa fa-check"></i><b>6</b> Simulation study: impact of misspecification in survival models with shared frailty terms</a><ul>
<li class="chapter" data-level="6.1" data-path="simst2-aim.html"><a href="simst2-aim.html"><i class="fa fa-check"></i><b>6.1</b> Aim</a></li>
<li class="chapter" data-level="6.2" data-path="simst2-dgms.html"><a href="simst2-dgms.html"><i class="fa fa-check"></i><b>6.2</b> Data-generating mechanisms</a></li>
<li class="chapter" data-level="6.3" data-path="simst2-methods.html"><a href="simst2-methods.html"><i class="fa fa-check"></i><b>6.3</b> Methods</a></li>
<li class="chapter" data-level="6.4" data-path="simst2-est.html"><a href="simst2-est.html"><i class="fa fa-check"></i><b>6.4</b> Estimands</a></li>
<li class="chapter" data-level="6.5" data-path="simst2-pm.html"><a href="simst2-pm.html"><i class="fa fa-check"></i><b>6.5</b> Performance measures</a></li>
<li class="chapter" data-level="6.6" data-path="simst2-res.html"><a href="simst2-res.html"><i class="fa fa-check"></i><b>6.6</b> Results</a></li>
<li class="chapter" data-level="6.7" data-path="simst2-conclusions.html"><a href="simst2-conclusions.html"><i class="fa fa-check"></i><b>6.7</b> Conclusions</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="sirex.html"><a href="sirex.html"><i class="fa fa-check"></i><b>7</b> Exploring results from simulation studies interactively</a></li>
<li class="chapter" data-level="8" data-path="infvp.html"><a href="infvp.html"><i class="fa fa-check"></i><b>8</b> Informative visiting process</a></li>
<li class="chapter" data-level="9" data-path="future.html"><a href="future.html"><i class="fa fa-check"></i><b>9</b> Future research developments</a></li>
<li class="chapter" data-level="10" data-path="pdevelop.html"><a href="pdevelop.html"><i class="fa fa-check"></i><b>10</b> Personal development</a><ul>
<li class="chapter" data-level="10.1" data-path="supervisory-meetings.html"><a href="supervisory-meetings.html"><i class="fa fa-check"></i><b>10.1</b> Supervisory meetings</a></li>
<li class="chapter" data-level="10.2" data-path="training-and-courses.html"><a href="training-and-courses.html"><i class="fa fa-check"></i><b>10.2</b> Training and courses</a></li>
<li class="chapter" data-level="10.3" data-path="conferences.html"><a href="conferences.html"><i class="fa fa-check"></i><b>10.3</b> Conferences</a></li>
</ul></li>
<li class="appendix"><span><b>Appendix</b></span></li>
<li class="chapter" data-level="A" data-path="ax-tables.html"><a href="ax-tables.html"><i class="fa fa-check"></i><b>A</b> Tables</a></li>
<li class="chapter" data-level="B" data-path="ax-plots.html"><a href="ax-plots.html"><i class="fa fa-check"></i><b>B</b> Plots</a></li>
<li class="chapter" data-level="C" data-path="ax-slides.html"><a href="ax-slides.html"><i class="fa fa-check"></i><b>C</b> Slides</a><ul>
<li class="chapter" data-level="C.1" data-path="ax-slides-safjr.html"><a href="ax-slides-safjr.html"><i class="fa fa-check"></i><b>C.1</b> 2017 SAfJR Conference</a></li>
<li class="chapter" data-level="C.2" data-path="ax-slides-sam-iscb.html"><a href="ax-slides-sam-iscb.html"><i class="fa fa-check"></i><b>C.2</b> 2017 SAM Conference and ISCB Conference</a></li>
<li class="chapter" data-level="C.3" data-path="ax-slides-students-day.html"><a href="ax-slides-students-day.html"><i class="fa fa-check"></i><b>C.3</b> Students’ Day at the 2017 ISCB Conference</a></li>
</ul></li>
<li class="chapter" data-level="D" data-path="ax-manuscript.html"><a href="ax-manuscript.html"><i class="fa fa-check"></i><b>D</b> Manuscript draft</a></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Probation review report</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="compch-numintgr" class="section level2">
<h2><span class="header-section-number">4.1</span> Numerical integration</h2>
<p>The term numerical integration implies the approximation of the integral of a function; generally, it aims to use the minimum number of function evaluations possible as it tends to be numerically expensive. There is a variety of methods being proposed in the literature to perform numerical integration; throughout this Section, I will focus on quadrature rules, i.e. any method that evaluates the function to be integrated at some points over the integration domain and combines the resulting values to obtain an approximation of the integral. Quadrature rules vary in complexity and accuracy, and generally accuracy improves as rules get more complex. Additionally, integration of functions in few dimensions is generally not too problematic; the task becomes more difficult when integrating over many dimensions as obtaining an acceptable level of accuracy often requires an unfeasible number of function evaluations.</p>
<div id="compch-numintgr-uni" class="section level3">
<h3><span class="header-section-number">4.1.1</span> Unidimensional functions</h3>
<p>The simplest method to approximate numerically the integral of a unidimensional function <span class="math inline">\(f(x)\)</span> over an integration domain <span class="math inline">\([a, b]\)</span> is given by the Riemann sum. A particular form of Riemann sum is given by the midpoint rule, which approximates the integral of a continuous function by the area under a set of <span class="math inline">\(N\)</span> step functions, with the midpoint of each matching <span class="math inline">\(f\)</span>: <span class="math display">\[
\int_a^b f(x) \ dx \approx \frac{b - a}{N} \sum_{i = 1}^N f(a + (i - 0.5)(b - a) / N)
\]</span> Alternatively, the trapezoidal rule approximates the area under a continuous function as a trapezoid and then computes its area: <span class="math display">\[
\int_a^b f(x) \ dx \approx (b - a) \left[ \frac{f(a) + f(b)}{2} \right]
\]</span> it works best when partitioning the integration area into many subintervals, applying the trapezoidal rule to all of them, and then summing the results: <span class="math display">\[
\int_a^b f(x) \ dx \approx \sum_{i = 1} ^ N \frac{f(x_{k - 1}) + f(x)}{2} \Delta(x_k),
\]</span> with <span class="math inline">\({x_k}\)</span> a partition of <span class="math inline">\([a, b]\)</span> such that <span class="math inline">\(a = x_0 &lt; x_1 &lt; x_2 &lt; \dots &lt; X_{N-1} &lt; x_N = b\)</span> and <span class="math inline">\(\Delta(x_k) = x_k - x_{k - 1}\)</span> the length of the <span class="math inline">\(k\)</span><sup>th</sup> subinterval.</p>
<p>The accuracy of the midpoint and trapezoidal rules depends on the number of steps (subintervals) <span class="math inline">\(N\)</span> used to approximate the function, but so does complexity (computationally speaking). The only requirement for applying these rules is that one needs to be able to evaluate the function <span class="math inline">\(f(x)\)</span> at a given point in its domain. If <span class="math inline">\(f(x)\)</span> is cheap to evaluate than the midpoint and trapezoidal rules may be just fine; otherwise, it would be better to move onto more complicated methods that yield more accurate results.</p>
<p>A first method that is only slightly more complicated but yields better results is the Simpson’s rule. It works analogously to the midpoint and trapezoidal rule, but using a smooth quadratic interpolant which takes the same values as <span class="math inline">\(f(x)\)</span> at the extremities of the integration interval <span class="math inline">\([a, b]\)</span> and at the midpoint <span class="math inline">\(m = (a + b) / 2\)</span>: <span class="math display">\[
\int_a^b f(x) \ dx \approx \frac{b - a}{6} \left[ f(a) + 4f((a + b) / 2) + f(b) \right]
\]</span> Analogously as the trapezoidal rule, it is possible to obtain greater accuracy by splitting the integration interval into many subintervals, applying the Simpson’s rule to each subinterval, and adding up the results.</p>
<p>Second, it is possible to show that by carefully choosing the points at which to evaluate <span class="math inline">\(f(x)\)</span> and the weights assigned to each point it is possible to obtain an exact approximation of the integral of any polynomial of degree <span class="math inline">\(2N - 1\)</span> or less with <span class="math inline">\(N\)</span> function evaluations (proof in <span class="citation">Monahan (<a href="#ref-monahan_2011">2011</a>)</span>). Methods that exploit this feature are commonly named Gaussian quadrature methods. Let <span class="math inline">\(f(x)\)</span> be a function of order <span class="math inline">\(2N - 1\)</span> or less to integrate over a conventional domain <span class="math inline">\([-1, 1]\)</span>; let <span class="math inline">\(w(x)\)</span> be a weight function. The quadrature formula is defined as: <span class="math display">\[
\int_{-1}^{1} f(x) \ dx = \sum_{i = 1} ^ N w_i f(x_i)
\]</span> Before applying Gaussian quadrature, any integral over the domain <span class="math inline">\([a, b]\)</span> needs to be changed to to the interval <span class="math inline">\([-1, 1]\)</span>. The change of interval is applied as <span class="math display">\[
\int_a^b f(x) \ dx = \frac{b - a}{2} \int_{-1}^{1} f\left( \frac{b - a}{2} x + \frac{a + b}{2} \right) \ dx,
\]</span> and the Gaussian quadrature rule is then <span class="math display">\[
\int_a^b f(x) \ dx = \frac{b - a}{2} \sum_{i = 1} ^ N w_i f\left( \frac{b - a}{2} x_i + \frac{a + b}{2} \right).
\]</span> If <span class="math inline">\(f(x) = w(x) g(x)\)</span> can be written as the product of a polynomial function <span class="math inline">\(g(x)\)</span> and a known weighting function <span class="math inline">\(w(x)\)</span>, alternative weights <span class="math inline">\(w_i&#39;\)</span> and nodes <span class="math inline">\(x_i&#39;\)</span> give better results: <span class="math display">\[
\int_{-1}^{1} f(x) \ dx = \int_{-1}^{1} w(x) g(x) \ dx = \sum_{i = 1} ^ N w_i&#39; f(x_i&#39;)
\]</span> Depending on the choice of the weighting function <span class="math inline">\(w(x)\)</span>, different Gaussian quadrature rules can be obtained that allow integrating over different domains <span class="math inline">\([a, b]\)</span>. When <span class="math inline">\(w(x) = 1\)</span>, the associated polynomials <span class="math inline">\(g(x)\)</span> are Legendre polynomials, the quadrature rule is then named Gauss-Legendre quadrature rule, and it allows integrating over the interval <span class="math inline">\([-1, 1]\)</span>. The integration points are then obtained as the the <span class="math inline">\(N\)</span> roots of the Legendre polynomials: <span class="math inline">\(x = \{x_1, x_2, \dots, x_N\}\)</span>. When choosing the weight function <span class="math inline">\(\exp(-x)\)</span> the associated polynomials are Laguerre polynomials, the quadrature rule is named Gauss-Laguerre quadrature rule, and the integration domain is <span class="math inline">\([0, +\infty)\)</span>. Finally, when choosing the weight function <span class="math inline">\(\exp(-x^2)\)</span> the associated polynomials are Hermite polynomials, the quadrature rule is named Gauss-Hermite quadrature rule, and the integration domain is <span class="math inline">\((-\infty, +\infty)\)</span>.</p>
<p>Finally, a slightly more complicated version of Gaussian quadrature is given by the Gauss–Kronrod quadrature formula. In the Gauss-Kronrod quadrature rule, the evaluation points are chosen dynamically so that an accurate approximation can be computed by reusing the information produced by the computation of a less accurate approximation. In practice, integration points from previous iterations can be reused as part of the new set of points, whereas usual Gaussian quadrature would require recomputation of all abscissas at each iteration. This is particularly important when some specified degree of accuracy is needed but the number of points needed to achieve this accuracy is not known ahead of time. Gauss-Kronrod quadrature rule is implemented in R as the <code>integrate()</code> function.</p>
</div>
<div id="compch-numintgr-multi" class="section level3">
<h3><span class="header-section-number">4.1.2</span> Multidimensional functions</h3>
<p>All the methods presented so far only apply to the integration of unidimensional functions. It is clearly possible to extend quadrature rules to multidimensional settings, by recursively applying unidimensional quadrature rules. Say I want to approximate the integral of a bi-dimensional function <span class="math inline">\(f(x, y)\)</span>; the bi-dimensional Gaussian quadrature rule has the form: <span class="math display">\[
\int_X \int_Y f(x, y) \ dx \ dy \approx \sum_j \sum_i w_j w_i f(x_j, y_i)
\]</span> This can be extended to any number of dimensions <span class="math inline">\(d\)</span>, but it gets very computationally expensive very quickly as a <span class="math inline">\(N\)</span>-points rule requires <span class="math inline">\(N^d\)</span> function evaluations. Two simple tricks for improving accuracy and efficiency are given in <span class="citation">Jäckel (<a href="#ref-jackel_2005">2005</a>)</span> and consist in pruning and/or rotating the matrix of location nodes. When pruning the matrix of nodes, those with extremely low weights that therefore contribute very little to the total integral value can be removed to spare some computational cost. Conversely, when rotating the matrix of nodes the correlation between the <span class="math inline">\(d\)</span> dimensions is taken into account. For instance, assume I am integrating over the random effects of a joint model for longitudinal and survival data; the random effects variance-covariance matrix can be decomposed using either the Cholesky decomposition or the spectral decomposition, and consequently the matrix of location nodes can be pre-multiplied by such decomposition to rotate the grid of integration points, better adapting to the shape of the multidimensional function to integrate.</p>
<p>A better option when the number of dimensions <span class="math inline">\(d\)</span> to integrate over is high is given by <em>Monte Carlo</em> integration. Consider integrating a multidimensional function <span class="math inline">\(f(x)\)</span> over some region <span class="math inline">\(\Omega\)</span> of volume <span class="math inline">\(V(\Omega)\)</span>: <span class="math display">\[
I_{\Omega} = \int_{\Omega} f(x) \ dx = E[f(U)] V(\Omega),
\]</span> with <span class="math inline">\(U \sim\)</span> uniform over <span class="math inline">\(\Omega\)</span>. Drawing <span class="math inline">\(N\)</span> uniform random vectors <span class="math inline">\(u_i\)</span> an estimator for <span class="math inline">\(I_{\Omega}\)</span> is <span class="math display">\[
\hat{I}_{\Omega} = \frac{V(\Omega)}{N} \sum_{i = 1} ^ N f(u_i);
\]</span> this estimator defines Monte Carlo integration. More details in <span class="citation">Monahan (<a href="#ref-monahan_2011">2011</a>)</span>.</p>
<p>Both Gaussian quadrature and Monte Carlo integration can be further tweaked to improve accuracy and convergence rates: two appealing options are, respectively, adaptive Gaussian quadrature and importance sampling. Adaptive Gaussian quadrature works best when using the Gauss-Hermite rule with the normal density kernel as weighting function. Recall using the spectral or Cholesky decomposition of the random effects variance-covariance to pre-multiply the matrix of location nodes. This will not place the nodes in optimum locations for each subject: if between-subject variability is large, then a common matrix of location nodes is likely to be quite inefficient. Adaptive Gauss-Hermite quadrature, as proposed by <span class="citation">Pinheiro and Bates (<a href="#ref-pinheiro_1995">1995</a>)</span>, aims to solve this problem. In brief, the idea consists in applying subject-specific (or cluster-specific) centring and scaling of the quadrature nodes to place the quadrature nodes at an optimal position for each subject. That is achieved by using an alternative normal kernel distribution <span class="math inline">\(\phi(x; \hat{M}_i, \hat{\Sigma}_i)\)</span> with subject-specific mean vector <span class="math inline">\(\hat{M}_i\)</span> and variance-covariance matrix <span class="math inline">\(\hat{\Sigma}_i\)</span>: <span class="math display">\[
f(x) = \frac{f(x)}{\phi(x; \hat{M}_i, \hat{\Sigma}_i)} \phi(x; \hat{M}_i, \hat{\Sigma}_i)
\]</span> This yields a quadrature rule based on the subject-specific normal kernel: the location nodes and weights then depend on <span class="math inline">\(\hat{M}_i\)</span> and <span class="math inline">\(\hat{\Sigma}_i\)</span>. Further, <span class="math inline">\(\hat{M}_i\)</span> and <span class="math inline">\(\hat{\Sigma}_i\)</span> can be updated iteratively (e.g. using empirical Bayes estimates) to better adapt the grid of quadrature points to the actual shape of the integral to approximate as the accuracy of predicting <span class="math inline">\(\hat{M}_i\)</span> and <span class="math inline">\(\hat{\Sigma}_i\)</span> increases. Conversely, Monte Carlo integration works best when it is possible to draw a sample from the target distribution (i.e. the distribution of the integral to approximate); unfortunately, that is rarely the case in practice. The idea of importance sampling consists then in drawing a sample from a proposal distribution and then re-weight the estimated integral using importance weights to better adapt to the target distribution.</p>
</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-monahan_2011">
<p>Monahan, John F. 2011. <em>Numerical Methods of Statistics</em>. 2nd ed. Statistical and Probabilistic Mathematics. Cambridge University Press.</p>
</div>
<div id="ref-jackel_2005">
<p>Jäckel, Peter. 2005. “A Note on Multivariate Gauss-Hermite Quadrature.” <a href="http://awdz65.dsl.pipex.com/ANoteOnMultivariateGaussHermiteQuadrature.pdf" class="uri">http://awdz65.dsl.pipex.com/ANoteOnMultivariateGaussHermiteQuadrature.pdf</a>.</p>
</div>
<div id="ref-pinheiro_1995">
<p>Pinheiro, José C, and Douglas M Bates. 1995. “Approximations to the Log-Likelihood Function in the Nonlinear Mixed-Effects Model.” <em>Journal of Computational and Graphical Statistics</em> 4 (1): 12–35. doi:<a href="https://doi.org/10.2307/1390625">10.2307/1390625</a>.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="compch.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="compch-numdiff.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": ["Probation_review_report_AG.pdf"],
"toc": {
"collapse": "section"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
